<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <title>Professional SVG Terminal - Risk Management</title>
    <link rel="icon" href="logo.png" type="image/png">
    <meta name="description" content="Professional SVG Terminal for crypto trading risk management. Calculate entry, take profit, stop loss and liquidation levels visually.">
    <meta name="keywords" content="trading, crypto, calculator, risk management, svg chart, binance, liquidation price">
    <meta name="author" content="c4t">

    <meta property="og:title" content="Calculator4Traders — Калькулятор для трейдеров">

    <meta property="og:description" content="Бесплатный инструмент для расчета рисков и размера позиции.">

    <meta property="og:image" content="https://calculator4traders.github.io/logo.png">

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://calculator4traders.github.io/">


    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:title" content="Professional SVG Terminal - Risk Management">
    <meta property="twitter:description" content="Visual trading calculator with real-time charts and liquidation price tracking.">
    <meta property="twitter:image" content="logo.png">

    <link rel="icon" type="image/png" href="logo.png">

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        body { background: #0f1a30; color: white; font-family: 'Trebuchet MS', sans-serif; margin: 0; display: flex; height: 100vh; overflow: hidden; }
        .calculator { 
            width: 300px; background: #1e2b47; padding: 20px; z-index: 10; 
            border-right: 1px solid #3a4f7a; flex-shrink: 0; overflow-y: auto; 
        }
        .calculator::-webkit-scrollbar { width: 4px; display: block; }
        .calculator::-webkit-scrollbar-thumb { background: #3a4f7a; border-radius: 10px; }

        .commission-warning { color: #ff9800; font-size: 12px; margin-bottom: 15px; text-align: center; border: 1px solid #ff9800; padding: 5px; border-radius: 4px; }
        .input-group { margin-bottom: 8px; }
        label { display: block; margin-bottom: 8px; color: #b8c7e0; font-size: 18px; }
        .label-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; color: #b8c7e0; }
        .label-row span:first-child { font-size: 18px; }
        .input-wrapper { position: relative; display: flex; align-items: center; }
        input, select { width: 100%; padding: 8.5px; padding-right: 30px; background: #2a3c5f; border: 1px solid #3a4f7a; border-radius: 5px; color: white; font-size: 14px; box-sizing: border-box; }
        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }
        .clear-input-btn { position: absolute; right: 10px; background: transparent; border: none; color: white; cursor: pointer; font-size: 16px; font-weight: bold; display: none; line-height: 1; }
        input:not(:placeholder-shown) + .clear-input-btn { display: block; }
        .result-value { font-size: 16px; font-weight: bold; color: #b8c7e0; }
        .side-selector { display: flex; gap: 10px; margin-top: 15px; margin-bottom: 15px; }
        .side-btn { flex: 1; padding: 12px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; opacity: 0.4; transition: 0.3s; font-size: 14px; }
        .side-btn.long { background: #26a69a; color: white; }
        .side-btn.short { background: #ef5350; color: white; }
        .side-btn.active { opacity: 1; box-shadow: 0 0 10px rgba(255,255,255,0.2); }
        hr { border: 0; border-top: 1px solid #3a4f7a; margin: 8px 0; }
        
        .chart-section { flex-grow: 1; position: relative; background: #131722; display: flex; flex-direction: column; }
        .tf-panel { background: #131722; padding: 10px 15px; display: flex; gap: 6px; border-bottom: 1px solid #2a2e39; flex-wrap: wrap; align-items: center; }
        .tf-btn { background: #1e222d; border: 1px solid #363c4e; color: #d1d4dc; cursor: pointer; padding: 5px 12px; font-size: 12px; border-radius: 4px; }
        .tf-btn.active { color: white; background: #2962ff; border-color: #2962ff; font-weight: bold; }
        .symbol-search { background: #1e222d; border: 1px solid #363c4e; color: #2962ff; padding: 5px 10px; font-size: 12px; border-radius: 4px; width: 110px; font-weight: bold; outline: none; }
        #svg-chart { width: 100%; flex-grow: 1; display: block; cursor: crosshair; touch-action: none; }
        .axis-text text { fill: #b8c7e0 !important; font-size: 16px !important; font-weight: 100 !important; user-select: none; }
        .grid-line { stroke: rgba(42, 46, 57, 0.6); }
        .axis-border { stroke: #363c4e; stroke-width: 1px; }
        .crosshair-line { stroke: #707d8b; stroke-width: 1; stroke-dasharray: 4,4; pointer-events: none; }
        .crosshair-label-bg { fill: #363c4e; } 
        .crosshair-label-text { fill: #b8c7e0; font-size: 13px; font-weight: bold; text-anchor: middle; }
        .price-label-main { fill: #b8c7e0; font-size: 16px; font-weight: 900; }
        .price-label-timer { fill: #ffffff; font-size: 12px; font-family: 'Courier New', monospace; font-weight: bold; }
        .price-line { stroke-width: 3px; cursor: ns-resize; }
        .line-label { font-size: 11px; font-weight: bold; pointer-events: none; }
        .h-sum-display { margin-left: 5px; margin-right: 5px; font-weight: bold; font-size: 14px; min-width: 30px; }
        .clear-h-btn { background: #363c4e; color: #ef5350; border: 1px solid #4a5266; cursor: pointer; padding: 2px 8px; font-size: 14px; border-radius: 4px; font-weight: bold; }

        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; justify-content: center; align-items: center; }
        .modal-content { background: #131722; width: 450px; border: 1px solid #363c4e; border-radius: 12px; position: relative; padding: 30px; box-sizing: border-box; text-align: center; }
        .close-modal { position: absolute; top: 15px; right: 20px; font-size: 24px; color: #ef5350; cursor: pointer; font-weight: bold; }
        
        .donate-container { display: flex; flex-direction: column; align-items: center; gap: 20px; margin-top: 10px; }
        .qr-wrapper { background: white; padding: 10px; border-radius: 8px; display: inline-block; }
        .crypto-selector { display: flex; gap: 8px; justify-content: center; margin-bottom: 5px; }
        .crypto-btn { background: #1e222d; border: 1px solid #363c4e; color: #b8c7e0; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; }
        .crypto-btn.active { border-color: #2962ff; color: white; background: #2962ff; }
        .address-display { font-family: monospace; font-size: 11px; color: #2962ff; background: #1e222d; padding: 10px; border-radius: 4px; word-break: break-all; cursor: pointer; border: 1px dashed #363c4e; }
        .address-display:active { background: #2962ff; color: white; }

        .instruction-text { color: #b8c7e0; font-size: 14px; line-height: 1.6; text-align: left; margin-bottom: 25px; background: rgba(41, 98, 255, 0.05); padding: 15px; border-radius: 8px; border: 1px solid #2a2e39; }
        .instruction-text b { color: #2962ff; }

        .fade-in { animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        @media (max-width: 768px) {
            body { display: flex; flex-direction: row; overflow-x: auto; scroll-snap-type: x mandatory; }
            .calculator, .chart-section { width: 100vw; min-width: 100vw; height: 100dvh; flex-shrink: 0; scroll-snap-align: start; }
            .calculator { padding: 10px 15px; overflow-y: auto; -webkit-overflow-scrolling: touch; box-sizing: border-box; }
            .tf-panel { flex-wrap: nowrap; overflow-x: auto; height: auto; min-height: 50px; }
            .modal-content { width: 90vw; padding: 20px; }
            #lang-selector { margin-left: 10px !important; }
        }
    </style>
</head>
<body>

<div id="info-modal" class="modal-overlay" onclick="if(event.target === this) toggleInfo(false)">
    <div class="modal-content">
        <span class="close-modal" onclick="toggleInfo(false)">✕</span>
        
        <div id="modal-start-view" style="display: flex; flex-direction: column; justify-content: flex-start; align-items: center;">
            <div class="instruction-text" id="modal-instruction">
                Калькулятор создан для удобства и визуализации сделок на графике. 
                Для открытия сделки нажмите кнопку <b>S/L</b>: первое нажатие на график создаст уровень входа, а второе — тейка. 
                Заполните поля: баланс, стоимость открытия и плечо. 
                Нажмите <b>OK</b> в окне баланс и получите расчет профита по тейку и уровень ликвидации на графике. 
                Уровни на графике можно перетаскивать(пока только в пк версии). 
                <br><br>
                <span style="color: #ff9800;">Помните что калькулятор не учитывает комиссии биржи!</span>
            </div>
            <button class="side-btn long active" id="btn-support-dev" style="opacity: 1; width: 100%; max-width: 280px;" onclick="showDonation()">Поддержать разработчика</button>
        </div>

        <div id="modal-donate-view" style="display: none;" class="fade-in">
            <div style="margin-bottom: 20px;">
                <svg width="60" height="60" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <rect width="100" height="100" rx="22" fill="black"/>
                    <text x="50" y="65" font-family="sans-serif" font-weight="900" font-size="42" fill="white" text-anchor="middle" style="letter-spacing: -2px;">c4t</text>
                </svg>
                <h3 style="margin: 10px 0 5px 0; color: white;">Support Terminal</h3>
            </div>

            <div class="crypto-selector">
                <button class="crypto-btn active" onclick="setCrypto('TRX')">USDT (TRC20)</button>
                <button class="crypto-btn" onclick="setCrypto('ETH')">ETH/ERC20</button>
                <button class="crypto-btn" onclick="setCrypto('XRP')">XRP</button>
            </div>

            <div class="donate-container">
                <div class="qr-wrapper" id="qrcode"></div>
                <div class="address-display" id="addr-text" title="Нажмите, чтобы скопировать">---</div>
                <small style="color: #b8c7e0; font-size: 10px;">Tap address to copy</small>
            </div>
        </div>
    </div>
</div>

<div class="calculator">
    <div class="commission-warning" id="lbl-comm-warn">калькулятор не учитывает комиссии биржи</div>
    <div class="input-group">
        <label id="lbl-entry">Вход (Цена актива)</label>
        <div class="input-wrapper">
            <input type="number" id="entryPrice" step="any" placeholder=" " oninput="calculateAll()">
            <button class="clear-input-btn" style="display:block; color:white;" onclick="calculateAll()">OK</button>
        </div>
    </div>
    <div class="input-group">
        <label id="lbl-take">Тейк</label>
        <div class="input-wrapper">
            <input type="number" id="takeProfit" step="any" placeholder=" " oninput="calculateAll()">
            <button class="clear-input-btn" style="display:block; color:white;" onclick="calculateAll()">OK</button>
        </div>
    </div>
    <div class="input-group">
        <label id="lbl-stop">Стоп</label>
        <div class="input-wrapper">
            <input type="number" id="stopLoss" step="any" placeholder=" ">
            <button class="clear-input-btn" style="display:block; color:white;" onclick="confirmStopLoss()">OK</button>
        </div>
    </div>
    <hr>
    <div class="input-group">
        <label id="lbl-balance">Баланс ($)</label>
        <div class="input-wrapper">
            <input type="number" id="balance" placeholder=" " oninput="handleBalanceInput()">
            <button class="clear-input-btn" style="display:block; color:white;" onclick="confirmBalance()">OK</button>
        </div>
    </div>
    <div class="input-group">
        <label id="lbl-margin">Стоимость открытия ($)</label>
        <div class="input-wrapper">
            <input type="number" id="marginCost" placeholder=" " oninput="calculateAll()">
            <button class="clear-input-btn" onclick="clearAllPurchases()">✕</button>
        </div>
    </div>
    <div class="input-group">
        <label id="lbl-add-margin">Докупить ($)</label>
        <div class="input-wrapper">
            <input type="number" id="addMargin" placeholder=" ">
            <button class="clear-input-btn" style="display:block; color:white;" onclick="executeDCA()">OK</button>
        </div>
    </div>
    <div class="input-group">
        <label id="lbl-add-price">По цене</label>
        <div class="input-wrapper">
            <input type="number" id="addPrice" step="any" placeholder=" ">
            <button class="clear-input-btn" onclick="clearInput('addPrice')">✕</button>
        </div>
    </div>
    <hr>
    <div class="input-group"><label id="lbl-lev">Плечо</label><input type="number" id="leverage" value="3" placeholder=" " oninput="calculateAll()"></div>
    
    <div class="input-group">
        <label id="lbl-partial-percent">Закрыть часть сделки %</label>
        <div class="input-wrapper">
            <input type="number" id="partialPercent" placeholder=" ">
            <button class="clear-input-btn" style="display:block; color:white;" onclick="executePartialClose()">OK</button>
        </div>
    </div>
    <div class="input-group">
        <label id="lbl-partial-price">По цене</label>
        <div class="input-wrapper">
            <input type="number" id="partialPrice" step="any" placeholder=" ">
            <button class="clear-input-btn" onclick="clearInput('partialPrice')">✕</button>
        </div>
    </div>
    <hr>

    <div class="side-selector">
        <button class="side-btn long active" id="btn-long" onclick="setSide('long')">LONG</button>
        <button class="side-btn short" id="btn-short" onclick="setSide('short')">SHORT</button>
    </div>
    <div class="input-group">
        <div class="label-row"><span id="lbl-liq-text">Ликвидация</span><span id="liqPrice" class="result-value">0.00</span></div>
    </div>
    <div class="input-group">
        <div class="label-row"><span id="lbl-profit">Профит по тейку ($)</span><span id="takeProfitValue" class="result-value">0.00</span></div>
    </div>
    <div class="input-group">
        <div class="label-row"><span id="lbl-loss">Потери по стопу ($)</span><span id="stopLossValue" class="result-value">0.00</span></div>
    </div>
</div>

<div class="chart-section">
    <div class="tf-panel" id="tf-panel"></div>
    <svg id="svg-chart"></svg>
</div>

<datalist id="symbolsList"></datalist>

<script>
    const WALLETS = {
        TRX: "TW8wa1QRMdJuwVgwnjA6wCRAMxE5UXHT5M",
        ETH: "0x9096cB9D2b34149d39D1b591C3D1544c0A4902F4",
        XRP: "rP8werJEtkhbXBHhB4HpkfLtgVuE35rg81"
    };

    let qrGenerator = null;

    function toggleInfo(show) { 
        document.getElementById('info-modal').style.display = show ? 'flex' : 'none'; 
        if(show) {
            document.getElementById('modal-start-view').style.display = 'flex';
            document.getElementById('modal-donate-view').style.display = 'none';
        }
    }

    function showDonation() {
        document.getElementById('modal-start-view').style.display = 'none';
        document.getElementById('modal-donate-view').style.display = 'block';
        setCrypto('TRX');
    }

    function setCrypto(key) {
        document.querySelectorAll('.crypto-btn').forEach(b => {
            b.classList.toggle('active', b.innerText.includes(key) || (key === 'TRX' && b.innerText.includes('USDT')));
        });

        const addr = WALLETS[key];
        const container = document.getElementById("qrcode");
        const textEl = document.getElementById("addr-text");
        
        container.innerHTML = ""; 
        textEl.innerText = addr;

        new QRCode(container, {
            text: addr,
            width: 150,
            height: 150,
            colorDark : "#000000",
            colorLight : "#ffffff",
            correctLevel : QRCode.CorrectLevel.H
        });

        textEl.onclick = () => {
            navigator.clipboard.writeText(addr);
            const originalText = textEl.innerText;
            textEl.innerText = "COPIED!";
            setTimeout(() => { textEl.innerText = originalText; }, 1000);
        };
    }

    const i18n = {
        ru: { entry: "Вход (Цена актива)", take: "Тейк", stop: "Стоп", balance: "Баланс ($)", margin: "Стоимость открытия ($)", addMargin: "Докупить ($)", addPrice: "По цене", lev: "Плечо", liq: "Ликвидация", profit: "Профит по тейку ($)", loss: "Потери по стопу ($)", confirmClear: "Вы точно хотите удалить ВСЕ тени?", promptResult: "Введите результат сделки:", liqCross: "Ликвидация (Cross)", liqMargin: "Ликвидация (Margin)", partialPercent: "Закрыть часть сделки %", partialPrice: "По цене", infoText: "Калькулятор создан для удобства и визуализации сделок на графике. Для открытия сделки нажмите кнопку <b>S/L</b>: первое нажатие на график создаст уровень входа, а второе — тейка. Заполните поля: баланс, стоимость открытия и плечо. Нажмите <b>OK</b> в окне баланс и получите расчет профита по тейку и уровень ликвидации на графике. Уровни на графике можно перетаскивать(пока только в пк версии). <br><br> <span style='color: #ff9800;'>Помните что калькулятор не учитывает комиссии биржи!</span>", donateBtn: "Поддержать разработчика", warn: "калькулятор не учитывает комиссии биржи" },
        en: { entry: "Entry Price", take: "Take Profit", stop: "Stop Loss", balance: "Balance ($)", margin: "Margin Cost ($)", addMargin: "Add Margin ($)", addPrice: "At Price", lev: "Leverage", liq: "Liquidation", profit: "TP Profit ($)", loss: "SL Loss ($)", confirmClear: "Are you sure you want to delete ALL zones?", promptResult: "Enter trade result:", liqCross: "Liquidation (Cross)", liqMargin: "Liquidation (Margin)", partialPercent: "Close Part %", partialPrice: "At Price", infoText: "The calculator is designed for convenience and visualizing trades on the chart. To open a trade, press <b>S/L</b>: the first click sets entry, the second sets take profit. Fill in: balance, margin cost, and leverage. Press <b>OK</b> in the balance field to see TP profit and liquidation level. You can drag levels on the chart. <br><br> <span style='color: #ff9800;'>Remember, the calculator does not account for exchange fees!</span>", donateBtn: "Support Developer", warn: "calculator does not account for fees" },
        zh: { entry: "入场价格", take: "止盈", stop: "止损", balance: "余额 ($)", margin: "开仓成本 ($)", addMargin: "加仓 ($)", addPrice: "加仓价格", lev: "杠杆", liq: "强平价格", profit: "预计盈利 ($)", loss: "预计亏损 ($)", confirmClear: "确定要删除所有区域吗？", promptResult: "输入交易结果:", liqCross: "强平 (全仓)", liqMargin: "强平 (逐仓)", partialPercent: "部分平仓 %", partialPrice: "平仓价格", infoText: "该计算器旨在方便用户在图表上可视化交易。点击 <b>S/L</b>：第一次点击设置入场，第二次点击设置止盈。填写余额、开仓成本和杠杆。点击余额栏의 <b>OK</b> 查看盈利和强平线。您可以拖动图表上的线条。<br><br><span style='color: #ff9800;'>请记住，计算器未计入交易所手续费！</span>", donateBtn: "支持开发者", warn: "计算器不考虑交易所手续费" },
        hi: { entry: "प्रवेश मूल्य", take: "मुनाफा", stop: "स्टॉप लॉस", balance: "बैलेंस ($)", margin: "মাজিন लागत ($)", addMargin: "মাজিন जोड़ें ($)", addPrice: "कीमत पर", lev: "लीवरेज", liq: "लिक्विडेशन", profit: "टीपी लाभ ($)", loss: "एसएल हानि ($)", confirmClear: "क्या आप सभी क्षेत्रों को हटाना चाहते हैं?", promptResult: "व्यापार परिणाम दर्ज करें:", liqCross: "लिक्विडेशन (Cross)", liqMargin: "लिक्विडेशन (Margin)", partialPercent: "हिसा बंद करें %", partialPrice: "कीमत पर", infoText: "कैलकुलेटर चार्ट पर ट्रेडों की कल्पना करने के लिए बनाया गया है। <b>S/L</b> दबाएं: पहला क्लिक एंट्री, दूसरा टीपी सेट करता है। बैलेंस, मार्जिन और लीवरेज भरें। टीपी प्रॉफिट और लิก्विडेशन देखने के लिए बैलेंस में <b>OK</b> दबाएं। आप चार्ट पर स्तरों को खींच सकते हैं।<br><br><span style='color: #ff9800;'>याद रखें, कैलकुलेटर एक्सचेंज फीस को नहीं जोड़ता है!</span>", donateBtn: "डेवलपर का समर्थन करें", warn: "कैलकुलेटर एक्सचेंज फीस को नहीं जोड़ता है" },
        es: { entry: "Precio de Entrada", take: "Take Profit", stop: "Stop Loss", balance: "Saldo ($)", margin: "Costo de Margen ($)", addMargin: "Añadir Margen ($)", addPrice: "Al Precio", lev: "Apalancamiento", liq: "Liquidación", profit: "Ganancia TP ($)", loss: "Pérdida SL ($)", confirmClear: "¿Seguro que quieres borrar todas las zonas?", promptResult: "Resultado de la operación:", liqCross: "Liquidación (Cross)", liqMargin: "Liquidación (Margin)", partialPercent: "Cierre Parcial %", partialPrice: "Al Precio", infoText: "Calculadora para visualizar operaciones. Pulsa <b>S/L</b>: primer clic entrada, segundo clic TP. Rellena saldo, margen y apalancamiento. Pulsa <b>OK</b> en saldo para ver beneficios y liquidación. Puedes arrastrar los niveles en el gráfico.<br><br><span style='color: #ff9800;'>¡Recuerde que no incluye comisiones!</span>", donateBtn: "Apoyar al desarrollador", warn: "la calculadora no incluye comisiones" },
        fr: { entry: "Prix d'Entrée", take: "Take Profit", stop: "Stop Loss", balance: "Solde ($)", margin: "Marge ($)", addMargin: "Ajouter Marge ($)", addPrice: "Au Prix", lev: "Levier", liq: "Liquidation", profit: "Profit TP ($)", loss: "Perte SL ($)", confirmClear: "Supprimer toutes les zones ?", promptResult: "Résultat du trade:", liqCross: "Liquidation (Cross)", liqMargin: "Liquidación (Margin)", partialPercent: "Fermeture Partielle %", partialPrice: "Au Prix", infoText: "Calculatrice pour visualiser les trades. Appuyez sur <b>S/L</b> : 1er clic entrée, 2e clic TP. Remplissez solde, marge et levier. Cliquez sur <b>OK</b> pour voir le profit et la liquidation. Les niveaux sont déplaçables.<br><br><span style='color: #ff9800;'>Attention, ne prend pas en compte les frais !</span>", donateBtn: "Soutenir le développeur", warn: "ne prend pas en compte les frais" },
        ar: { entry: "سعر الدخول", take: "جني الأرباح", stop: "وقف الخсارة", balance: "الرصيد ($)", margin: "التكلفة ($)", addMargin: "إضافة هامش ($)", addPrice: "عند السعر", lev: "الرافعة المالية", liq: "التصفية", profit: "ربح TP ($)", loss: "خسارة SL ($)", confirmClear: "هل أنت متأكد من مسح جميع المناطق؟", promptResult: "أدخل نتيجة الصفقة:", liqCross: "تصفية (Cross)", liqMargin: "تصفية (Margin)", partialPercent: "إغلاق جزئي %", partialPrice: "عند السعر", infoText: "تمออกแบบมาเพื่อการจำลองเทรด กด <b>S/L</b>: คลิกแรกคือทางเข้า คลิกสองคือ TP กรอกยอดเงินและเลเวอเรจเพื่อดูจุดเลิกกิจการ ลากเส้นบนกราфได้<br><br><span style='color: #ff9800;'>โปรดทราบว่าไม่รวมค่าธรรมเนียม!</span>", donateBtn: "دعم المطور", warn: "الحاسبة لا تحتسب رسوم المنصة" },
        bn: { entry: "এন্ট্রি প্রাইস", take: "টেক প্রফিট", stop: "স্টপ লস", balance: "ব্যালেন্স ($)", margin: "মার্জিন খরচ ($)", addMargin: "মার্জিন যোগ করুন ($)", addPrice: "মূল্য নির্ধারণ", lev: "লিভারেজ", liq: "লিকুইডেশন", profit: "টিপি লাভ ($)", loss: "এসএল ক্ষতি ($)", confirmClear: "আপনি কি সব জোন মুছতে চান?", promptResult: "ট্রেড রেজাল্ট লিখুন:", liqCross: "লিকুইডেশন (Cross)", liqMargin: "লিকুইডেশন (Margin)", partialPercent: "আংশিক বন্ধ %", partialPrice: "মূল্য নির্ধারণ", infoText: "ট্রেড ভিজ্যুয়ালাইজ করার জন্য ক্যালকুলেটর। <b>S/L</b> চাপুন: ১ম ক্লিকে এন্ট্রি, ২য় ক্লিকে TP সেট হবে। ব্যালেন্স, মার্জিন এবং লিভারেজ পূরণ করুন। প্রফিট দেখতে ব্যালেন্সে <b>OK</b> চাপুন। লেভেলগুলো ড্র্যাগ করা যায়।<br><br><span style='color: #ff9800;'>মনে রাখবেন, এটি এক্সচেঞ্জ ফি গণনা করে না!</span>", donateBtn: "ডেভেলপারকে समर्थन করুন", warn: "এটি এক্সচেঞ্জ ফি গণনা করে না" },
        pt: { entry: "Preço de Entrada", take: "Take Profit", stop: "Stop Loss", balance: "Saldo ($)", margin: "Custo de Margен ($)", addMargin: "Adicionar Margem ($)", addPrice: "Ao Preço", lev: "Alavancagem", liq: "Liquidação", profit: "Lucro TP ($)", loss: "Perda SL ($)", confirmClear: "Limpar todas as zonas?", promptResult: "Resultado da operação:", liqCross: "Liquidação (Cross)", liqMargin: "Liquidação (Margin)", partialPercent: "Fechar Parte %", partialPrice: "Ao Preço", infoText: "Calculadora para visualizar negociações. Pressione <b>S/L</b>: 1º clique entrada, 2º clique TP. Preencha saldo, margem e alavancagem. Pressione <b>OK</b> para ver lucro e liquidação. Níveis arrastáveis.<br><br><span style='color: #ff9800;'>A calculadora não incluye taxas da exchange!</span>", donateBtn: "Apoiar desenvolvedor", warn: "a calculadora não incluye taxas" },
        ja: { entry: "エントリー価格", take: "利確", stop: "損切", balance: "残高 ($)", margin: "証拠金 ($)", addMargin: "追加入金 ($)", addPrice: "価格指定", lev: "レバレッジ", liq: "ロスカット価格", profit: "予定利益 ($)", loss: "予定損失 ($)", confirmClear: "すべてのゾーンを削除しますか？", promptResult: "取引結果を入力:", liqCross: "清算 (クロス)", liqMargin: "清算 (分離)", partialPercent: "部分利確 %", partialPrice: "価格指定", infoText: "チャート上で取引を可視化します。<b>S/L</b>を押し, 1回目のクリックでエントリー, 2回目で利確を設定。残高、証拠金、レバレッジを入力し、<b>OK</b>を押すと利益と清算ラインが表示されます。ラインはドラッグ可能です。<br><br><span style='color: #ff9800;'>取引所の手数料は考慮されません。</span>", donateBtn: "開発者を支援する", warn: "取引所の手数料は考慮されません" }
    };
    
    let currentLang = localStorage.getItem('lang') || 'ru';
    let candles = [], currentTF = '15m', currentSide = 'long', currentSymbol = 'BTCUSDT';
    let symbolSettings = JSON.parse(localStorage.getItem('terminalSettings')) || {}, historyZones = JSON.parse(localStorage.getItem('tradeHistoryZones')) || [], dcaLines = [], closeLines = []; 
    let isHMode = false, hStep = 0, hTemp = null, activeTradeStartTime = null;
    let confirmedBalanceBase = null;
    let confirmedStopLossValue = null; 

    let isDcaOrderActive = false;
    let isPartialOrderActive = false;
    let isSLMode = false; 

    let margin = { top: 20, right: (window.innerWidth <= 768 ? 60 : 110), bottom: 40, left: 10 };
    let yScale = d3.scaleLinear(), xScale = d3.scaleBand(), mousePos = null, slStep = 0; 
    const svg = d3.select("#svg-chart");
    const defs = svg.append("defs");
    defs.append("clipPath").attr("id", "chart-clip").append("rect").attr("x", 0).attr("y", 0);
    const mainG = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
    const contentG = mainG.append("g").attr("clip-path", "url(#chart-clip)"), overlayG = mainG.append("g"), crosshairG = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
    let yDomain = [0, 0], visibleCount = 80, scrollOffset = 0, isDragging = false, lastMouse = { x: 0, y: 0 };
    let isPriceScaling = false; 
    let initialPinchDist = null; 

    const tfMap = { '1s': 1, '1m': 60, '5m': 300, '15m': 900, '1h': 3600, '4h': 14400, '1d': 86400, '1w': 604800, '1M': 2592000, '1y': 31536000 };
    const timeframes = ['1s', '1m', '5m', '15m', '1h', '4h', '1d', '1w', '1M', '1y'];
    const tfPanel = document.getElementById('tf-panel');
    timeframes.forEach(tf => {
        const btn = document.createElement('button');
        btn.className = `tf-btn ${tf === currentTF ? 'active' : ''}`;
        btn.innerText = tf;
        btn.onclick = () => { currentTF = tf; document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active')); btn.classList.add('active'); loadData(true); };
        tfPanel.appendChild(btn);
    });
    const slBtn = document.createElement('button'); slBtn.className = 'tf-btn sl-mode-btn'; slBtn.innerText = 'S/L'; slBtn.onclick = toggleSLMode; tfPanel.appendChild(slBtn);
    const symbolInput = document.createElement('input'); symbolInput.className = 'symbol-search'; symbolInput.setAttribute('list', 'symbolsList'); symbolInput.value = currentSymbol;
    symbolInput.onfocus = function() { this.value = ''; }; symbolInput.onblur = function() { if (this.value === '') this.value = currentSymbol; };
    symbolInput.onchange = (e) => {
        const val = e.target.value.toUpperCase();
        if (val) {
            currentSymbol = val; const s = symbolSettings[currentSymbol] || {};
            document.getElementById('entryPrice').value = s.entry || ""; document.getElementById('takeProfit').value = s.tp || ""; 
            document.getElementById('stopLoss').value = s.sl || ""; confirmedStopLossValue = s.sl || null; 
            document.getElementById('marginCost').value = s.margin || ""; 
            document.getElementById('leverage').value = s.leverage || "3";
            closeLines = s.closeLines || [];
            if (s.side) setSide(s.side); loadData(true).then(() => calculateAll());
        }
    };
    tfPanel.appendChild(symbolInput);
    const hBtn = document.createElement('button'); hBtn.className = 'tf-btn'; hBtn.innerText = 'H'; hBtn.onclick = () => { isHMode = !isHMode; hStep = 0; hBtn.classList.toggle('active', isHMode); if(isHMode && isSLMode) toggleSLMode(); }; tfPanel.appendChild(hBtn);
    const sumDisplay = document.createElement('div'); sumDisplay.className = 'h-sum-display'; sumDisplay.id = 'h-total-sum'; sumDisplay.innerText = '0'; tfPanel.appendChild(sumDisplay);
    const clearHBtn = document.createElement('button'); clearHBtn.className = 'clear-h-btn'; clearHBtn.innerText = '✖'; clearHBtn.onclick = () => { if (confirm(i18n[currentLang].confirmClear)) { historyZones = []; localStorage.setItem('tradeHistoryZones', JSON.stringify(historyZones)); update(); } }; tfPanel.appendChild(clearHBtn);
    
    const infoBtn = document.createElement('button'); infoBtn.className = 'tf-btn info-btn'; infoBtn.innerText = 'Info'; infoBtn.onclick = () => toggleInfo(true); tfPanel.appendChild(infoBtn);

    // LANGUAGE SELECTOR IMPLEMENTATION
    const langSelector = document.createElement('select');
    langSelector.id = 'lang-selector';
    langSelector.className = 'symbol-search';
    langSelector.style.width = '130px';
    langSelector.style.marginLeft = 'auto';

    const popularLanguages = [
        {c: 'ru', n: 'Русский'}, {c: 'en', n: 'English'}, {c: 'zh', n: '简体中文'}, {c: 'hi', n: 'हिन्दी'},
        {c: 'es', n: 'Español'}, {c: 'fr', n: 'Français'}, {c: 'ar', n: 'العربية'}, {c: 'bn', n: 'বাংলা'},
        {c: 'pt', n: 'Português'}, {c: 'ja', n: '日本語'}
    ];

    popularLanguages.forEach(lang => {
        const opt = document.createElement('option');
        opt.value = lang.c;
        opt.innerText = lang.n;
        if(lang.c === currentLang) opt.selected = true;
        langSelector.appendChild(opt);
    });

    langSelector.onchange = (e) => {
        currentLang = e.target.value;
        localStorage.setItem('lang', currentLang);
        applyLanguage();
    };
    tfPanel.appendChild(langSelector);

    function applyLanguage() { 
        const t = i18n[currentLang] || i18n['en']; 
        document.getElementById('lbl-entry').innerText = t.entry; 
        document.getElementById('lbl-take').innerText = t.take; 
        document.getElementById('lbl-stop').innerText = t.stop; 
        document.getElementById('lbl-balance').innerText = t.balance; 
        document.getElementById('lbl-margin').innerText = t.margin; 
        document.getElementById('lbl-add-margin').innerText = t.addMargin; 
        document.getElementById('lbl-add-price').innerText = t.addPrice; 
        document.getElementById('lbl-lev').innerText = t.lev; 
        document.getElementById('lbl-profit').innerText = t.profit; 
        document.getElementById('lbl-loss').innerText = t.loss; 
        document.getElementById('lbl-liq-text').innerText = t.liq; 
        document.getElementById('lbl-partial-percent').innerText = t.partialPercent; 
        document.getElementById('lbl-partial-price').innerText = t.partialPrice; 
        document.getElementById('lbl-comm-warn').innerText = t.warn;
        
        // Modal Translation
        document.getElementById('modal-instruction').innerHTML = t.infoText;
        document.getElementById('btn-support-dev').innerText = t.donateBtn;

        calculateAll(); 
    }

    async function initSymbols() { try { const res = await fetch('https://api.binance.com/api/v3/exchangeInfo'); const data = await res.json(); let list = data.symbols.filter(s => s.status === 'TRADING' && s.quoteAsset === 'USDT').map(s => s.symbol); const sortedList = ['BTCUSDT', 'ETHUSDT', ...list.filter(item => !['BTCUSDT', 'ETHUSDT'].includes(item))]; const datalist = document.getElementById('symbolsList'); datalist.innerHTML = ''; sortedList.forEach(s => { const opt = document.createElement('option'); opt.value = s; datalist.appendChild(opt); }); } catch(e) { console.error(e); } }
    
    function toggleSLMode() { 
        isSLMode = !isSLMode; 
        slStep = 0; 
        if (isSLMode) {
            document.getElementById('entryPrice').value = "";
            document.getElementById('takeProfit').value = "";
            document.getElementById('stopLoss').value = "";
            confirmedStopLossValue = null;
            activeTradeStartTime = null;
            dcaLines = [];
            closeLines = [];
            isDcaOrderActive = false;
            isPartialOrderActive = false;
            calculateAll();
        }
        slBtn.classList.toggle('active', isSLMode); 
        svg.style("cursor", isSLMode ? "crosshair" : "default"); 
        if(isSLMode && isHMode) { isHMode = false; hBtn.classList.remove('active'); } 
    }

    function setSide(side) { currentSide = side; document.getElementById('btn-long').classList.toggle('active', side === 'long'); document.getElementById('btn-short').classList.toggle('active', side === 'short'); calculateAll(); }
    
    function handleBalanceInput() { confirmedBalanceBase = null; } 
    function confirmBalance() {
        const currentBal = +document.getElementById('balance').value;
        confirmedBalanceBase = currentBal; 
        calculateAll();
    }

    function confirmStopLoss() {
        const stopVal = document.getElementById('stopLoss').value;
        confirmedStopLossValue = stopVal ? +stopVal : null;
        calculateAll();
    }

    function executeDCA() {
        const addM = +document.getElementById('addMargin').value, addP = +document.getElementById('addPrice').value;
        if (addM && addP) { isDcaOrderActive = true; update(); }
    }
    
    function executePartialClose() {
        const percent = +document.getElementById('partialPercent').value, price = +document.getElementById('partialPrice').value;
        if (percent > 0 && price) { isPartialOrderActive = true; update(); }
    }

    function performDCAExecution() {
        const currentEntry = +document.getElementById('entryPrice').value, currentMargin = +document.getElementById('marginCost').value, addM = +document.getElementById('addMargin').value, addP = +document.getElementById('addPrice').value;
        if (currentEntry && currentMargin && addM && addP) {
            const newEntry = ((currentMargin * currentEntry) + (addM * addP)) / (currentMargin + addM), newMargin = currentMargin + addM;
            document.getElementById('entryPrice').value = newEntry.toFixed(newEntry < 1 ? 4 : 2); document.getElementById('marginCost').value = newMargin.toFixed(2); dcaLines.push(addP); 
            document.getElementById('addMargin').value = ""; document.getElementById('addPrice').value = ""; 
            isDcaOrderActive = false; 
            calculateAll();
        }
    }

    function performPartialCloseExecution() {
        const entry = +document.getElementById('entryPrice').value, 
              currentMargin = +document.getElementById('marginCost').value, 
              percent = +document.getElementById('partialPercent').value, 
              price = +document.getElementById('partialPrice').value, 
              lev = +document.getElementById('leverage').value, 
              balanceEl = document.getElementById('balance');

        if (entry && currentMargin && percent > 0 && price && candles.length > 0) {
            const totalPos = currentMargin * lev;
            const currentTotalProfit = (currentSide === 'long' ? (price - entry)/entry : (entry - price)/entry) * totalPos;
            const profitToBalance = currentTotalProfit * (percent / 100);
            
            const lastCandleTime = candles[candles.length-1].time;
            historyZones.push({ id: Date.now(), symbol: currentSymbol, t1: activeTradeStartTime || lastCandleTime, p1: entry, t2: lastCandleTime, p2: price, val: profitToBalance.toFixed(2) });
            localStorage.setItem('tradeHistoryZones', JSON.stringify(historyZones));

            const marginToSubtract = currentMargin * (percent / 100);
            const newMargin = currentMargin - marginToSubtract;
            document.getElementById('marginCost').value = newMargin.toFixed(2);
            
            if (confirmedBalanceBase !== null) {
                confirmedBalanceBase += profitToBalance;
                balanceEl.value = confirmedBalanceBase.toFixed(2);
            } else if (balanceEl.value) {
                balanceEl.value = (+balanceEl.value + profitToBalance).toFixed(2);
            }
            
            closeLines.push({ price: price, profit: profitToBalance });
            document.getElementById('partialPercent').value = ""; document.getElementById('partialPrice').value = "";
            isPartialOrderActive = false; 
            calculateAll();
        }
    }

    function calculateAll() {
        const entryVal = document.getElementById('entryPrice').value, balanceEl = document.getElementById('balance'), marginVal = document.getElementById('marginCost').value, levVal = document.getElementById('leverage').value, tpVal = document.getElementById('takeProfit').value;
        const slPrice = confirmedStopLossValue; 
        const lastPrice = candles.length ? candles[candles.length - 1].close : 0;
        
        if (currentSymbol) { 
            symbolSettings[currentSymbol] = { entry: entryVal, tp: tpVal, sl: confirmedStopLossValue, margin: marginVal, leverage: levVal, side: currentSide, closeLines: closeLines }; 
            localStorage.setItem('terminalSettings', JSON.stringify(symbolSettings)); 
        }
        
        if (entryVal && tpVal && !activeTradeStartTime && candles.length > 0) {
            if (mousePos) {
                const domain = xScale.domain(), idx = Math.floor(mousePos.x / xScale.step()), mouseTime = domain[idx];
                activeTradeStartTime = mouseTime || candles[candles.length-1].time;
            } else { activeTradeStartTime = candles[candles.length-1].time; }
        }
        
        if (!entryVal || !tpVal) { activeTradeStartTime = null; confirmedBalanceBase = null; }

        if (confirmedBalanceBase !== null && entryVal && marginVal && lastPrice) {
            const entry = +entryVal, marginCost = +marginVal, lev = +levVal, totalPos = marginCost * lev;
            const livePnl = (currentSide === 'long' ? (lastPrice - entry)/entry : (entry - lastPrice)/entry) * totalPos;
            balanceEl.value = (confirmedBalanceBase + livePnl).toFixed(2);
        }

        if (!entryVal || !marginVal || !levVal) { document.getElementById('liqPrice').innerText = "0.00"; document.getElementById('takeProfitValue').innerText = "0.00"; document.getElementById('stopLossValue').innerText = "0.00"; update(); return; }
        const entry = +entryVal, balance = +balanceEl.value || 0, marginCost = +marginVal, lev = +levVal, tpPrice = +tpVal || 0, totalPos = marginCost * lev;
        
        let liq = currentSide === 'long' ? entry * (1 - (balance > 0 ? balance/totalPos : 1/lev)) : entry * (1 + (balance > 0 ? balance/totalPos : 1/lev));
        const t = i18n[currentLang] || i18n['en']; document.getElementById('lbl-liq-text').innerText = balance > 0 ? t.liqCross : t.liqMargin;
        document.getElementById('liqPrice').innerText = Math.max(0, liq).toFixed(2);
        
        document.getElementById('takeProfitValue').innerText = tpPrice > 0 ? ((currentSide === 'long' ? (tpPrice - entry)/entry : (entry - tpPrice)/entry) * totalPos).toFixed(2) : "0.00";
        document.getElementById('stopLossValue').innerText = slPrice > 0 ? ((currentSide === 'long' ? (slPrice - entry)/entry : (entry - slPrice)/entry) * totalPos).toFixed(2) : "0.00";
        update(); 
    }

    function clearInput(id) {
        const input = document.getElementById(id); input.value = "";
        if (id === 'addPrice') isDcaOrderActive = false;
        if (id === 'partialPrice') isPartialOrderActive = false;
        if (id === 'stopLoss') confirmedStopLossValue = null; 
        if (currentSymbol && symbolSettings[currentSymbol]) {
            const map = { 'entryPrice': 'entry', 'takeProfit': 'tp', 'stopLoss': 'sl', 'marginCost': 'margin' };
            if (map[id]) symbolSettings[currentSymbol][map[id]] = ""; localStorage.setItem('terminalSettings', JSON.stringify(symbolSettings));
        }
        calculateAll();
    }
    function clearAllPurchases() { dcaLines = []; closeLines = []; isDcaOrderActive = false; isPartialOrderActive = false; document.getElementById('marginCost').value = ""; document.getElementById('entryPrice').value = ""; if (currentSymbol && symbolSettings[currentSymbol]) { symbolSettings[currentSymbol].margin = ""; symbolSettings[currentSymbol].entry = ""; symbolSettings[currentSymbol].closeLines = []; localStorage.setItem('terminalSettings', JSON.stringify(symbolSettings)); } calculateAll(); }
    function getTimeLeft() { if (!candles.length) return ""; const interval = tfMap[currentTF] === 31536000 ? 2592000 : tfMap[currentTF], nextTime = candles[candles.length - 1].time + (interval * 1000), diff = nextTime - Date.now(); if (diff <= 0) return "00:00"; const h = Math.floor(diff / 3600000), m = Math.floor((diff % 3600000) / 60000), s = Math.floor((diff % 60000) / 1000); return h > 0 ? `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}` : `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`; }
    
    function checkAutoTriggers(lastPrice) {
        if (isSLMode) return; 
        
        const entry = +document.getElementById('entryPrice').value, tp = +document.getElementById('takeProfit').value, sl = confirmedStopLossValue, addP = +document.getElementById('addPrice').value, partP = +document.getElementById('partialPrice').value;
        if (!entry || !tp) return;
        
        if (isDcaOrderActive && addP && ((currentSide === 'long' && lastPrice <= addP) || (currentSide === 'short' && lastPrice >= addP))) { performDCAExecution(); }
        if (isPartialOrderActive && partP && ((currentSide === 'long' && lastPrice >= partP) || (currentSide === 'short' && lastPrice <= partP))) { performPartialCloseExecution(); }

        const isTP = (currentSide === 'long' && lastPrice >= tp) || (currentSide === 'short' && lastPrice <= tp), isSL = sl && ((currentSide === 'long' && lastPrice <= sl) || (currentSide === 'short' && lastPrice >= sl));
        if (isTP || isSL) {
            const marginCost = +document.getElementById('marginCost').value, lev = +document.getElementById('leverage').value, totalPos = marginCost * lev, balanceEl = document.getElementById('balance');
            const pnl = (currentSide === 'long' ? (lastPrice - entry)/entry : (entry - lastPrice)/entry) * totalPos;
            historyZones.push({ id: Date.now(), symbol: currentSymbol, t1: activeTradeStartTime, p1: entry, t2: candles[candles.length-1].time, p2: lastPrice, val: pnl.toFixed(2) });
            localStorage.setItem('tradeHistoryZones', JSON.stringify(historyZones));
            
            const finalBal = (confirmedBalanceBase !== null ? confirmedBalanceBase : +balanceEl.value) + pnl;
            balanceEl.value = finalBal.toFixed(2);
            confirmedBalanceBase = finalBal; 

            clearInput('entryPrice'); clearInput('takeProfit'); clearInput('stopLoss'); clearInput('marginCost'); dcaLines = []; closeLines = [];
            activeTradeStartTime = null; confirmedStopLossValue = null; calculateAll();
        }
    }

    async function loadData(resetView = false) { 
        try { 
            let apiInterval = currentTF === '1y' ? '1M' : currentTF; 
            const res = await fetch(`https://api.binance.com/api/v3/klines?symbol=${currentSymbol}&interval=${apiInterval}&limit=1000`); 
            const data = await res.json(); 
            candles = data.map(d => ({ time: d[0], open: +d[1], high: +d[2], low: +d[3], close: +d[4] })); 
            if (candles.length > 0) { 
                const lastPrice = candles[candles.length - 1].close; 
                const addPriceEl = document.getElementById('addPrice'), partialPriceEl = document.getElementById('partialPrice');
                
                // ОБНОВЛЕНИЕ: Подставляем текущую цену, если поле не в фокусе и ордер не активен
                if (!isDcaOrderActive && !addPriceEl.matches(':focus')) { 
                    addPriceEl.value = lastPrice.toFixed(lastPrice < 1 ? 4 : 2); 
                }
                if (!isPartialOrderActive && !partialPriceEl.matches(':focus')) { 
                    partialPriceEl.value = lastPrice.toFixed(lastPrice < 1 ? 4 : 2); 
                }
                
                checkAutoTriggers(lastPrice); 
            } 
            if (resetView) { scrollOffset = 0; const last = candles.slice(-visibleCount); yDomain = [d3.min(last, d => d.low) * 0.99, d3.max(last, d => d.high) * 1.01]; } 
            update(); calculateAll(); 
        } catch (e) { console.error(e); } 
    }
    
    function findXByTime(targetTime, domain) { const exact = xScale(targetTime); if (exact !== undefined) return exact; for (let i = 0; i < domain.length; i++) { const currentCandleTime = domain[i], nextCandleTime = domain[i+1] || (currentCandleTime + tfMap[currentTF] * 1000); if (targetTime >= currentCandleTime && targetTime < nextCandleTime) return xScale(currentCandleTime); } return undefined; }
    
    function update() {
        const rect = svg.node().getBoundingClientRect(); if (rect.width === 0) return;
        const iw = rect.width - margin.left - margin.right, ih = rect.height - margin.top - margin.bottom;
        d3.select("#chart-clip rect").attr("width", iw).attr("height", ih);
        yScale.domain(yDomain).range([ih, 0]);
        const startIdx = candles.length - visibleCount - scrollOffset, data = candles.slice(Math.max(0, startIdx), Math.max(0, candles.length - scrollOffset)), timeStep = tfMap[currentTF] * 1000, domainData = [];
        if (candles.length > 0) { for (let i = 0; i < visibleCount; i++) domainData.push(candles[0].time + (startIdx + i) * (candles.length > 1 ? (candles[1].time - candles[0].time) : timeStep)); }
        xScale.domain(domainData).range([0, iw]).padding(0.2);
        contentG.selectAll("*").remove(); overlayG.selectAll("*").remove();
        contentG.append("g").attr("transform", `translate(${iw}, 0)`).attr("class", "axis-text").call(d3.axisRight(yScale).tickSize(-iw).tickPadding(10)).call(g => g.select(".domain").remove()).selectAll("line").attr("class", "grid-line");
        overlayG.append("g").attr("transform", `translate(${iw}, 0)`).attr("class", "axis-text").call(d3.axisRight(yScale).tickSize(0).tickPadding(10)).call(g => g.select(".domain").remove());
        overlayG.append("g").attr("transform", `translate(0, ${ih})`).attr("class", "axis-text").call(d3.axisBottom(xScale).tickValues(xScale.domain().filter((d, i) => i % Math.ceil(visibleCount/8) === 0)).tickFormat(d => { const date = new Date(d); return ['1y','1M'].includes(currentTF) ? date.toLocaleDateString([], {month:'short', year:'2-digit'}) : date.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); }).tickSize(0).tickPadding(12)).call(g => g.select(".domain").remove());
        overlayG.append("line").attr("class", "axis-border").attr("x1", iw).attr("x2", iw).attr("y1", 0).attr("y2", ih);
        overlayG.append("line").attr("class", "axis-border").attr("x1", 0).attr("x2", iw).attr("y1", ih).attr("y2", ih);
        const gC = contentG.selectAll(".c").data(data).enter().append("g");
        gC.append("line").attr("stroke", d => d.close > d.open ? "#26a69a" : "#ef5350").attr("x1", d => xScale(d.time) + xScale.bandwidth()/2).attr("x2", d => xScale(d.time) + xScale.bandwidth()/2).attr("y1", d => yScale(d.high)).attr("y2", d => yScale(d.low));
        gC.append("rect").attr("fill", d => d.close > d.open ? "#26a69a" : "#ef5350").attr("x", d => xScale(d.time)).attr("y", d => yScale(Math.max(d.open, d.close))).attr("width", xScale.bandwidth()).attr("height", d => Math.max(1, Math.abs(yScale(d.open) - yScale(d.close))));
        
        const domain = xScale.domain(), entry = +document.getElementById('entryPrice').value, tp = +document.getElementById('takeProfit').value, lastPrice = candles.length ? candles[candles.length-1].close : 0;
        if (entry && tp && activeTradeStartTime) {
            let x1 = findXByTime(activeTradeStartTime, domain), x2 = iw - xScale.bandwidth();
            if (x1 === undefined && domain.length > 0 && activeTradeStartTime < domain[0]) x1 = 0;
            if (x1 !== undefined) {
                const y1 = yScale(entry), y2 = yScale(lastPrice);
                contentG.append("rect").attr("x", Math.min(x1, x2)).attr("y", Math.min(y1, y2)).attr("width", Math.abs(x2 - x1) + xScale.bandwidth()).attr("height", Math.max(2, Math.abs(y2 - y1))).attr("fill", (currentSide === 'long' ? lastPrice >= entry : lastPrice <= entry) ? "#26a69a" : "#ef5350").attr("opacity", 0.3);
            }
        }
        
        if (isDcaOrderActive && +document.getElementById('addPrice').value) {
            const yAdd = yScale(+document.getElementById('addPrice').value);
            contentG.append("line").attr("class", "price-line").attr("x1", 0).attr("x2", iw).attr("y1", yAdd).attr("y2", yAdd).attr("stroke", "#2962ff").attr("stroke-width", 2).attr("stroke-dasharray", "4,4")
                .call(d3.drag().on("drag", (e) => { const [mx, my] = d3.pointer(e, mainG.node()); const p = yScale.invert(Math.max(0, Math.min(ih, my))); document.getElementById('addPrice').value = p.toFixed(p < 1 ? 4 : 2); update(); }));
        }

        if (isPartialOrderActive && +document.getElementById('partialPrice').value) {
            const yPart = yScale(+document.getElementById('partialPrice').value);
            contentG.append("line").attr("class", "price-line").attr("x1", 0).attr("x2", iw).attr("y1", yPart).attr("y2", yPart).attr("stroke", "#26a69a").attr("stroke-width", 2).attr("stroke-dasharray", "4,4")
                .call(d3.drag().on("drag", (e) => { const [mx, my] = d3.pointer(e, mainG.node()); const p = yScale.invert(Math.max(0, Math.min(ih, my))); document.getElementById('partialPrice').value = p.toFixed(p < 1 ? 4 : 2); update(); }));
        }

        dcaLines.forEach(price => { const yDca = yScale(price); if (yDca >= 0 && yDca <= ih) contentG.append("line").attr("x1", 0).attr("x2", iw).attr("y1", yDca).attr("y2", yDca).attr("stroke", "#2962ff").attr("stroke-width", 1).attr("stroke-dasharray", "5,5"); });
        closeLines.forEach(item => { 
            const yClose = yScale(item.price); 
            if (yClose >= 0 && yClose <= ih) {
                contentG.append("line").attr("x1", 0).attr("x2", iw).attr("y1", yClose).attr("y2", yClose).attr("stroke", "#26a69a").attr("stroke-width", 1).attr("stroke-dasharray", "3,3"); 
                contentG.append("text").attr("x", iw/2).attr("y", yClose - 5).attr("fill", "#26a69a").attr("font-size", "14px").attr("font-weight", "bold").attr("text-anchor", "middle").text(`${item.profit >= 0 ? '+' : ''}${item.profit.toFixed(2)}`);
            }
        });
        historyZones.filter(z => z.symbol === currentSymbol).forEach((z) => {
            let x1 = findXByTime(z.t1, domain), x2 = findXByTime(z.t2, domain);
            if (x1 === undefined && domain.length > 0 && z.t1 < domain[0]) x1 = 0; if (x2 === undefined && domain.length > 0 && z.t2 > domain[domain.length-1]) x2 = iw - xScale.bandwidth();
            if (x1 !== undefined && x2 !== undefined) {
                const y1 = yScale(z.p1), y2 = yScale(z.p2), color = parseFloat(z.val) >= 0 ? "#26a69a" : "#ef5350";
                contentG.append("rect").attr("x", Math.min(x1, x2)).attr("y", Math.min(y1, y2)).attr("width", Math.abs(x2 - x1) + xScale.bandwidth()).attr("height", Math.max(2, Math.abs(y2 - y1))).attr("fill", color).attr("opacity", 0.3);
                const labelGroup = overlayG.append("g").attr("transform", `translate(${Math.min(x1, x2)}, ${Math.min(y1, y2) - 10})`);
                labelGroup.append("text").attr("fill", parseFloat(z.val) >= 0 ? "#26a69a" : "#ef5350").attr("font-size", "14px").attr("font-weight", "bold").text(`${parseFloat(z.val) > 0 ? "+" : ""}${z.val}`);
                labelGroup.append("text").attr("x", 50).attr("fill", "#ef5350").attr("cursor", "pointer").text(" [x]").on("click", () => { historyZones = historyZones.filter(item => item.id !== z.id); localStorage.setItem('tradeHistoryZones', JSON.stringify(historyZones)); update(); });
            }
        });
        if (hStep === 1 && mousePos && hTemp) { const tx1 = findXByTime(hTemp.t1, domain) || 0, tx2 = mousePos.x, ty1 = yScale(hTemp.p1), ty2 = mousePos.y; contentG.append("rect").attr("x", Math.min(tx1, tx2)).attr("y", Math.min(ty1, ty2)).attr("width", Math.abs(tx2 - tx1)).attr("height", Math.max(2, Math.abs(ty2 - ty1))).attr("fill", yScale.invert(ty2) > hTemp.p1 ? "#26a69a" : "#ef5350").attr("opacity", 0.4); }
        if (candles.length) {
            const last = candles[candles.length - 1], y = yScale(last.close), color = last.close >= last.open ? "#26a69a" : "#ef5350";
            contentG.append("line").attr("stroke", color).attr("stroke-dasharray", "4,4").attr("x1", 0).attr("x2", iw).attr("y1", y).attr("y2", y);
            const lG = overlayG.append("g").attr("transform", `translate(${iw}, ${y - 19})`);
            lG.append("rect").attr("width", margin.right).attr("height", 38).attr("fill", color).attr("rx", 3);
            lG.append("text").attr("class", "price-label-main").attr("x", margin.right/2).attr("y", 16).attr("text-anchor", "middle").text(last.close.toFixed(last.close < 1 ? 4 : 2));
            lG.append("text").attr("class", "price-label-timer").attr("x", margin.right/2).attr("y", 32).attr("text-anchor", "middle").text(getTimeLeft());
        }
        
        drawLevel("entryPrice", "#2962ff", (i18n[currentLang] || i18n['en']).entry.split(' ')[0].toUpperCase(), iw, +document.getElementById('entryPrice').value);
        drawLevel("takeProfit", "#26a69a", "TP", iw, +document.getElementById('takeProfit').value);
        if (confirmedStopLossValue !== null) {
            drawLevel("stopLoss", "#ef5350", "SL", iw, confirmedStopLossValue);
        }

        const liqVal = +document.getElementById('liqPrice').innerText;
        if (liqVal > 0) { const yLiq = yScale(liqVal); if (yLiq >= 0 && yLiq <= ih) { contentG.append("line").attr("x1", 0).attr("x2", iw).attr("y1", yLiq).attr("y2", yLiq).attr("stroke", "#ff9800").attr("stroke-width", 2).attr("stroke-dasharray", "5,5"); } }
        document.getElementById('h-total-sum').innerText = historyZones.reduce((acc, z) => acc + (parseFloat(z.val) || 0), 0).toFixed(2);
        renderCrosshair(iw, ih);
    }

    function renderCrosshair(iw, ih) {
        crosshairG.selectAll("*").remove(); 
        if (!mousePos) return; 
        const {x, y} = mousePos; 
        if (x < 0 || x > iw || y < 0 || y > ih) return;

        // Линии перекрестия
        crosshairG.append("line").attr("class", "crosshair-line").attr("x1", x).attr("x2", x).attr("y1", 0).attr("y2", ih); 
        crosshairG.append("line").attr("class", "crosshair-line").attr("x1", 0).attr("x2", iw).attr("y1", y).attr("y2", y);

        // Плашка цены (справа)
        const pG = crosshairG.append("g").attr("transform", `translate(${iw}, ${y - 13})`), pVal = yScale.invert(y);
        pG.append("rect").attr("class", "crosshair-label-bg").attr("width", margin.right).attr("height", 26).attr("rx", 3);
        pG.append("text").attr("class", "crosshair-label-text").attr("x", margin.right/2).attr("y", 17).text(pVal.toFixed(pVal < 1 ? 4 : 2));

        // Плашка времени (снизу)
        const domain = xScale.domain();
        const step = xScale.step();
        const idx = Math.floor(x / step);
        const tVal = domain[idx];

        if (tVal) {
            const date = new Date(tVal);
            const dateStr = date.toLocaleDateString([], {day:'2-digit', month:'2-digit'});
            const timeStr = date.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
            const fullStr = `${dateStr} ${timeStr}`;
            
            const tG = crosshairG.append("g").attr("transform", `translate(${x - 45}, ${ih})`);
            tG.append("rect").attr("class", "crosshair-label-bg").attr("width", 90).attr("height", 26).attr("rx", 3);
            tG.append("text").attr("class", "crosshair-label-text").attr("x", 45).attr("y", 17).text(fullStr);
        }
    }

    function drawLevel(id, color, label, iw, val) {
        if (!val) return; 
        const y = yScale(val), g = overlayG.append("g");
        g.append("line")
            .attr("x1", 0).attr("x2", iw).attr("y1", y).attr("y2", y)
            .style("stroke", "transparent")
            .style("stroke-width", "20px")
            .style("cursor", "ns-resize")
            .call(d3.drag().on("drag", (e) => { 
                const [mx, my] = d3.pointer(e, mainG.node()), ih = svg.node().getBoundingClientRect().height - margin.top - margin.bottom; 
                const p = yScale.invert(Math.max(0, Math.min(ih, my))); 
                const priceStr = p.toFixed(p < 1 ? 4 : 2);
                document.getElementById(id).value = priceStr;
                if (id === 'stopLoss') confirmedStopLossValue = +priceStr; 
                calculateAll(); 
            }));
        g.append("line").attr("class", "price-line").attr("x1", 0).attr("x2", iw).attr("y1", y).attr("y2", y).attr("stroke", color).style("stroke-width", "2px").style("pointer-events", "none"); 
        g.append("text").attr("class", "line-label").attr("x", iw + 5).attr("y", y + 4).attr("fill", color).text(label);
    }

    svg.on("click", (e) => {
        const rect = svg.node().getBoundingClientRect(), rx = e.clientX - rect.left - margin.left, ry = e.clientY - rect.top - margin.top;
        if (isSLMode) { const price = yScale.invert(ry); if (slStep === 0) { document.getElementById('entryPrice').value = price.toFixed(price < 1 ? 4 : 2); slStep = 1; } else if (slStep === 1) { document.getElementById('takeProfit').value = price.toFixed(price < 1 ? 4 : 2); toggleSLMode(); } calculateAll(); }
        else if (isHMode) {
            const price = yScale.invert(ry), domain = xScale.domain(), idx = Math.floor(rx / xScale.step()), time = domain[idx] || domain[domain.length-1];
            if (hStep === 0) { hTemp = { t1: time, p1: price }; hStep = 1; }
            else { const res = prompt((i18n[currentLang] || i18n['en']).promptResult, "0"); if (res !== null) { historyZones.push({ id: Date.now(), symbol: currentSymbol, t1: hTemp.t1, p1: hTemp.p1, t2: time, p2: price, val: res.replace(',', '.') }); localStorage.setItem('tradeHistoryZones', JSON.stringify(historyZones)); } hStep = 0; hTemp = null; isHMode = false; hBtn.classList.remove('active'); update(); }
        }
    });

    svg.on("mousemove", (e) => { const rect = svg.node().getBoundingClientRect(); mousePos = { x: e.clientX - rect.left - margin.left, y: e.clientY - rect.top - margin.top }; if (isSLMode && slStep === 1) { const entry = +document.getElementById('entryPrice').value, currentPrice = yScale.invert(mousePos.y); if (currentPrice > entry && currentSide !== 'long') setSide('long'); else if (currentPrice < entry && currentSide !== 'short') setSide('short'); document.getElementById('takeProfit').value = currentPrice.toFixed(currentPrice < 1 ? 4 : 2); calculateAll(); } else update(); }).on("mouseleave", () => { mousePos = null; crosshairG.selectAll("*").remove(); });
    svg.on("mousedown", (e) => { if (!e.target.classList.contains("price-line") && e.target.style.stroke !== "transparent") { isDragging = true; lastMouse = { x: e.clientX, y: e.clientY }; svg.classed("grabbing", true); } });
    
    const handleMove = (clientX, clientY, touches) => { 
        if (!isDragging || isSLMode || isHMode) return; 
        if (touches && touches.length === 2) {
            const dist = Math.abs(touches[0].clientX - touches[1].clientX);
            if (initialPinchDist === null) initialPinchDist = dist;
            else {
                const diff = initialPinchDist - dist;
                if (Math.abs(diff) > 5) { visibleCount = Math.max(5, Math.min(900, visibleCount + (diff > 0 ? 2 : -2))); initialPinchDist = dist; update(); }
            }
            return;
        }
        if (isPriceScaling && window.innerWidth <= 768) {
            const dy = clientY - lastMouse.y, range = yDomain[1] - yDomain[0], factor = dy * 0.005; 
            yDomain = [yDomain[0] - range * factor, yDomain[1] + range * factor]; 
            lastMouse.y = clientY; update(); return;
        }
        const dx = clientX - lastMouse.x, dy = clientY - lastMouse.y; 
        if (Math.abs(dx) > 1.5) { scrollOffset = Math.min(candles.length - 5, scrollOffset + Math.round(dx / 8)); lastMouse.x = clientX; } 
        const pDiff = yScale.invert(0) - yScale.invert(dy); 
        yDomain = [yDomain[0] + pDiff, yDomain[1] + pDiff]; lastMouse.y = clientY; update(); 
    };
    window.addEventListener("mousemove", (e) => handleMove(e.clientX, e.clientY));
    svg.on("touchstart", (e) => { 
        const touches = e.touches, rect = svg.node().getBoundingClientRect(), touchX = touches[0].clientX - rect.left - margin.left, iw = rect.width - margin.left - margin.right;
        if (e.target.classList.contains("price-line") || e.target.style.stroke === "transparent") { isDragging = false; return; }
        isDragging = true; lastMouse = { x: touches[0].clientX, y: touches[0].clientY }; 
        if (touches.length === 2) initialPinchDist = Math.abs(touches[0].clientX - touches[1].clientX);
        else if (window.innerWidth <= 768 && touchX > iw) isPriceScaling = true;
        else isPriceScaling = false;
    });
    window.addEventListener("touchmove", (e) => { if (isDragging || e.touches.length === 2) handleMove(e.touches[0].clientX, e.touches[0].clientY, e.touches); }, { passive: false });
    window.addEventListener("touchend", () => { isDragging = false; isPriceScaling = false; initialPinchDist = null; }); 
    window.addEventListener("mouseup", () => { isDragging = false; isPriceScaling = false; });
    svg.on("wheel", (e) => { e.preventDefault(); const rect = svg.node().getBoundingClientRect(); if ((e.clientX - rect.left) > (rect.width - margin.right)) { const range = yDomain[1] - yDomain[0], factor = e.deltaY * 0.0008; yDomain = [yDomain[0] - range * factor, yDomain[1] + range * factor]; } else visibleCount = Math.max(5, Math.min(900, visibleCount + (e.deltaY > 0 ? 5 : -5))); update(); });
    
    initSymbols(); 
    loadData(true).then(() => { applyLanguage(); calculateAll(); });
    setInterval(() => loadData(false), 3000);        
</script>
</body>
</html>